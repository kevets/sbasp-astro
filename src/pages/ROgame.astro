---
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../consts';
---



<!doctype html>
<html lang="en">
<head>
  <h3>GAMES</h3><br>
  				<li>RO: Running Ostrich üèÉ‚Äç‚ôÇÔ∏è‚Äç‚û°Ô∏è<a href="https://show.sbasp.com/ROgame">link</a></li><br>
  				<li>SSP: Squares, Spaces & Pairs ‚èπÔ∏è<a href="https://show.sbasp.com/SSPgame">link</a></li><br>
  <h3>NAV</h3><br>
  				<li>SHOW: üìö<a href="https://show.sbasp.com">link</a></li><br>
  				<li>SHOP: üî•<a href="https://shop.sbasp.com">link</a></li><br>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Runaway Ostrich ‚Äî games.SBASP</title>
  <style>
    /* Mobile-first responsive canvas layout */
    html,body{height:100%;margin:0;background:#8ecae6;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    .wrap{display:flex;flex-direction:column;height:100%;align-items:center;justify-content:flex-start;padding:8px;box-sizing:border-box}
    header{width:100%;max-width:900px;color:#023047;padding:6px 8px;font-weight:700}
    canvas{background:linear-gradient(#cbeefc,#8ecae6);border-radius:12px;touch-action:none}
    .hud{display:flex;gap:8px;align-items:center;justify-content:space-between;width:100%;max-width:900px;margin-top:8px}
    .panel{background:rgba(255,255,255,0.85);padding:6px 8px;border-radius:8px;box-shadow:0 6px 18px rgba(2,48,71,0.12)}
    .controls{display:flex;gap:10px;align-items:center}
    .btn{background:#ffb703;border-radius:10px;padding:8px 12px;font-weight:700;user-select:none}
    /* touch controls docked at bottom for mobile */
    .touch-controls{position:fixed;left:0;right:0;bottom:18px;display:flex;justify-content:center;pointer-events:none}
    .touch-row{width:100%;max-width:900px;display:flex;justify-content:space-between;pointer-events:auto;padding:0 12px}
    .touch-pad{background:rgba(2,48,71,0.9);color:white;border-radius:12px;padding:14px 18px;font-weight:800;opacity:0.9}
    .touch-pad.small{padding:12px 14px;border-radius:10px}
    .info{font-size:14px}
    @media(min-width:900px){.touch-controls{display:none}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      Runaway Ostrich ‚Äî Bounce-pad farm races
    </header>

    <canvas id="game" width="900" height="600"></canvas>

    <div class="hud" role="region" aria-label="game HUD">
      <div class="panel info">
        <div>Time: <span id="timer">0.00</span>s</div>
        <div>Lap: <span id="lap">0</span>/<span id="lapsTotal">3</span></div>
      </div>
      <div class="panel controls">
        <div class="btn" id="startBtn">Start Race</div>
        <div class="btn" id="resetBtn">Reset</div>
      </div>
      <div class="panel info">
        <div>Best: <span id="best">‚Äî</span>s</div>
      </div>
    </div>

    <div class="touch-controls">
      <div class="touch-row">
        <div style="display:flex;gap:8px;">
          <div class="touch-pad" id="leftBtn">‚óÄ</div>
          <div class="touch-pad" id="rightBtn">‚ñ∂</div>
        </div>
        <div style="display:flex;gap:8px;">
          <div class="touch-pad small" id="jumpBtn">JUMP</div>
          <div class="touch-pad small" id="boostBtn">BOUNCE</div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // Single-file 2D platformer game: Runaway Ostrich
  // Features: run/jump/bounce pads, mobile touch controls, timed laps with checkpoints (circuit tracks)

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;

  // scale canvas up/down to fit screen while keeping aspect ratio
  function fitCanvas(){
    const maxW = Math.min(window.innerWidth-16, 900);
    const scale = maxW / 900;
    canvas.style.width = Math.round(900*scale)+'px';
    canvas.style.height = Math.round(600*scale)+'px';
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // HUD
  const timerEl = document.getElementById('timer');
  const lapEl = document.getElementById('lap');
  const lapsTotalEl = document.getElementById('lapsTotal');
  const bestEl = document.getElementById('best');

  // Controls (keyboard & touch)
  const keys = {left:false,right:false,jump:false,bounce:false};
  window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') keys.left=true; if(e.key==='ArrowRight') keys.right=true; if(e.key===' '||e.key==='ArrowUp') keys.jump=true; if(e.key==='b') keys.bounce=true; });
  window.addEventListener('keyup', e=>{ if(e.key==='ArrowLeft') keys.left=false; if(e.key==='ArrowRight') keys.right=false; if(e.key===' '||e.key==='ArrowUp') keys.jump=false; if(e.key==='b') keys.bounce=false; });

  // touch buttons
  ['leftBtn','rightBtn','jumpBtn','boostBtn'].forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener('touchstart', e=>{ e.preventDefault(); el.classList.add('active'); if(id==='leftBtn') keys.left=true; if(id==='rightBtn') keys.right=true; if(id==='jumpBtn') keys.jump=true; if(id==='boostBtn') keys.bounce=true; });
    el.addEventListener('touchend', e=>{ e.preventDefault(); el.classList.remove('active'); if(id==='leftBtn') keys.left=false; if(id==='rightBtn') keys.right=false; if(id==='jumpBtn') keys.jump=false; if(id==='boostBtn') keys.bounce=false; });
    // mouse fallback
    el.addEventListener('mousedown', e=>{ e.preventDefault(); if(id==='leftBtn') keys.left=true; if(id==='rightBtn') keys.right=true; if(id==='jumpBtn') keys.jump=true; if(id==='boostBtn') keys.bounce=true; });
    el.addEventListener('mouseup', e=>{ e.preventDefault(); if(id==='leftBtn') keys.left=false; if(id==='rightBtn') keys.right=false; if(id==='jumpBtn') keys.jump=false; if(id==='boostBtn') keys.bounce=false; });
  });

  // Start/Reset
  document.getElementById('startBtn').addEventListener('click', ()=>{ if(!race.started) startRace(); });
  document.getElementById('resetBtn').addEventListener('click', resetGame);

  // World data
  const gravity = 0.9;
  const groundY = 520; // baseline

  // simple tile-like platforms and bounce pads
  const platforms = [
    {x:0,y:groundY,w:900,h:80},
    {x:120,y:420,w:250,h:16},
    {x:420,y:340,w:220,h:16},
    {x:720,y:300,w:160,h:16},
    {x:560,y:200,w:160,h:16}
  ];

  // bounce pads placed on certain platform segments
  const bouncePads = [
    {x:260,y:420-16,w:40,h:10,strength: -18},
    {x:490,y:340-16,w:40,h:10,strength: -20},
    {x:780,y:300-16,w:40,h:10,strength: -24}
  ];

  // circuit checkpoints in order (x positions) to form laps
  const checkpoints = [100, 400, 700, 850];
  let lapsTotal = 3;
  lapsTotalEl.textContent = lapsTotal;

  // Player
  const player = {
    x:40,y:groundY-56,w:44,h:56,vx:0,vy:0,onGround:false,facing:1,
    color:'#ff7b00',name:'Ostrich'
  };

  // Race state
  const race = {started:false,startTime:0,elapsed:0,lap:0,nextCheckpoint:0,finished:false,best: null};

  function startRace(){
    race.started=true;race.startTime=performance.now();race.elapsed=0;race.lap=0;race.nextCheckpoint=0;race.finished=false;
    lapEl.textContent = race.lap;
  }

  function resetGame(){
    race.started=false;race.elapsed=0;race.lap=0;race.nextCheckpoint=0;race.finished=false;player.x=40;player.y=groundY-56;player.vx=0;player.vy=0;timerEl.textContent='0.00';lapEl.textContent='0';
  }

  // Simple AABB collision
  function rectsIntersect(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // update loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(40, now - last); last = now;
    update(dt/16.6667);
    render();
    requestAnimationFrame(loop);
  }

  function update(t){
    // physics & input
    const accel = 0.7;
    if(keys.left){ player.vx = Math.max(player.vx - accel, -6); player.facing=-1; }
    else if(keys.right){ player.vx = Math.min(player.vx + accel, 6); player.facing=1; }
    else { player.vx *= 0.85; if(Math.abs(player.vx)<0.1) player.vx=0; }

    // apply gravity
    player.vy += gravity * (t);
    // jump if on ground and pressed
    if(keys.jump && player.onGround){ player.vy = -14; player.onGround = false; }

    // bounce pad manual boost (player requests) - short-range
    if(keys.bounce){
      // if player overlaps a bounce pad horizontally, trigger
      for(const bp of bouncePads){
        if(player.x + player.w > bp.x && player.x < bp.x + bp.w && Math.abs((player.y+player.h) - bp.y) < 80){
          player.vy = bp.strength; // negative value
        }
      }
    }

    // integrate
    player.x += player.vx * t;
    player.y += player.vy * t;

    // world collision with platforms
    player.onGround = false;
    for(const p of platforms){
      const platformRect = {x:p.x, y:p.y, w:p.w, h:p.h};
      const playerRect = {x:player.x, y:player.y, w:player.w, h:player.h};
      // simple vertical collision check
      if(player.vy >= 0 && player.x + player.w > p.x && player.x < p.x + p.w){
        const playerBottom = player.y + player.h;
        if(playerBottom > p.y && playerBottom < p.y + 40){
          // land on platform
          player.y = p.y - player.h; player.vy = 0; player.onGround = true;
        }
      }
    }

    // bounce pads collision: if player lands on pad from above, trigger bounce
    for(const bp of bouncePads){
      const pad = {x:bp.x, y:bp.y, w:bp.w, h:bp.h};
      const playerBottom = player.y + player.h;
      if(playerBottom > pad.y && playerBottom - player.vy <= pad.y && player.x + player.w > pad.x && player.x < pad.x + pad.w){
        // landed on pad
        player.y = pad.y - player.h; player.vy = bp.strength; player.onGround = false; // strong upwards
      }
    }

    // bounds
    if(player.y > H + 200){ // fell
      // respawn at last checkpoint or start
      player.x = 40; player.y = groundY - player.h; player.vx = 0; player.vy = 0;
    }

    // racing: check checkpoints in order (based on x position only)
    if(race.started && !race.finished){
      race.elapsed = (performance.now() - race.startTime)/1000;
      timerEl.textContent = race.elapsed.toFixed(2);
      const cpX = checkpoints[race.nextCheckpoint];
      if(player.x + player.w/2 >= cpX){
        // hit checkpoint
        race.nextCheckpoint++;
        if(race.nextCheckpoint >= checkpoints.length){
          // completed a lap
          race.lap++;
          race.nextCheckpoint = 0;
          lapEl.textContent = race.lap;
          if(race.lap >= lapsTotal){
            race.finished = true;
            race.started = false;
            // record best
            if(race.best === null || race.elapsed < race.best){ race.best = race.elapsed; bestEl.textContent = race.best.toFixed(2); }
            alert('Lap complete! Time: ' + race.elapsed.toFixed(2) + 's');
          }
        }
      }
    }
  }

  // render
  function render(){
    ctx.clearRect(0,0,W,H);

    // parallax sky
    ctx.fillStyle = '#bde0fe';
    ctx.fillRect(0,0,W,H);

    // draw platforms
    for(const p of platforms){
      ctx.fillStyle = '#6b4f3b';
      ctx.fillRect(p.x, p.y, p.w, p.h);
      // grass top
      ctx.fillStyle = '#2a9d8f';
      ctx.fillRect(p.x, p.y-8, p.w, 8);
    }

    // draw bounce pads
    for(const bp of bouncePads){
      ctx.fillStyle = '#ff4d6d';
      ctx.fillRect(bp.x, bp.y - bp.h, bp.w, bp.h);
      ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.strokeRect(bp.x, bp.y - bp.h, bp.w, bp.h);
    }

    // draw checkpoints
    for(let i=0;i<checkpoints.length;i++){
      const x = checkpoints[i];
      ctx.fillStyle = i===race.nextCheckpoint? 'rgba(255,195,0,0.95)':'rgba(255,255,255,0.35)';
      ctx.fillRect(x-4, 120, 8, 320);
    }

    // draw player (simple ostrich sprite block)
    ctx.save();
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath(); ctx.ellipse(player.x+player.w/2, player.y+player.h+10, player.w*0.6, 8, 0,0,Math.PI*2); ctx.fill();

    // body
    ctx.fillStyle = player.color;
    roundRect(ctx, player.x, player.y, player.w, player.h, 8, true, false);
    // beak
    ctx.fillStyle = '#ffd166';
    if(player.facing>0){
      ctx.beginPath(); ctx.moveTo(player.x+player.w, player.y+14); ctx.lineTo(player.x+player.w+10, player.y+player.h/2); ctx.lineTo(player.x+player.w, player.y+player.h-14); ctx.closePath(); ctx.fill();
    } else {
      ctx.beginPath(); ctx.moveTo(player.x, player.y+14); ctx.lineTo(player.x-10, player.y+player.h/2); ctx.lineTo(player.x, player.y+player.h-14); ctx.closePath(); ctx.fill();
    }
    // eye
    ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(player.x + (player.facing>0? player.w*0.6:player.w*0.4), player.y+player.h*0.28, 6,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(player.x + (player.facing>0? player.w*0.6:player.w*0.4), player.y+player.h*0.28, 3,0,Math.PI*2); ctx.fill();
    ctx.restore();

    // info text
    ctx.fillStyle = 'rgba(2,48,71,0.9)'; ctx.font = 'bold 16px system-ui';
    ctx.fillText('Runaway Ostrich', 12, 28);

  }

  // utility: round rect
  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    if(typeof r==='undefined') r=5; if(typeof r==='number') r={tl:r,tr:r,br:r,bl:r};
    ctx.beginPath(); ctx.moveTo(x+r.tl,y); ctx.lineTo(x+w-r.tr,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r.tr); ctx.lineTo(x+w,y+h-r.br); ctx.quadraticCurveTo(x+w,y+h,x+w-r.br,y+h); ctx.lineTo(x+r.bl,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r.bl); ctx.lineTo(x,y+r.tl); ctx.quadraticCurveTo(x,y,x+r.tl,y); ctx.closePath();
    if(fill) ctx.fill(); if(stroke) ctx.stroke();
  }

  // fit internal canvas coordinate size if device pixel ratio high
  function fixHiDPI(){
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(900 * dpr);
    canvas.height = Math.round(600 * dpr);
    W = canvas.width; H = canvas.height; ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fixHiDPI();

  // initial draw
  render();
  requestAnimationFrame(loop);
  </script>
</body>
</html>
